#!/bin/bash

set -e

error() {
	echo "ERROR: $@" 1>&2
	exit 1
}

info() {
	echo "INFO: $@" 1>&2
}

# Check dependencies
checkdeps() {
	type bunzip2 2>&1 >/dev/null || error "Please install [bunzip2]."
	type cosign 2>&1 >/dev/null || error "Please install [cosign]."
	type jq 2>&1 >/dev/null || error "Please install [jq]."
	type git 2>&1 >/dev/null || error "Please install [git]."
	type gzip 2>&1 >/dev/null || error "Please install [gzip]."
	type sha512sum 2>&1 >/dev/null || error "Please install [sha512sum]."
	type tar 2>&1 >/dev/null || error "Please install [tar]."
	type wget 2>&1 >/dev/null || error "Please install [wget]."
	type xz 2>&1 >/dev/null || error "Please install [xz]."
}

# Decode URLs
urldecode() { : "${*//+/ }"; echo -e "${_//%/\\x}"; }

usage() {
	echo "
$0 [OPTIONS] IMAGE[:TAG]

Options:
 -p|--platform [amd64|arm64]	Default = amd64
 --dry-run			Dry run (skip actual source downloads)

Image:		Image short name, as in the * in: cgr.dev/chainguard/*
		  - wolfi-base:latest
		  - python:3.11
		  - openjdk
		Default tag = :latest

This tool will create a new directory in your present working directory called
sources/  It will then download the SBOM associated with your specified image,
and then fetch all upstream sources with git and/or wget, at the specific
commit used in the image (git), or checked against a checksum (wget).
"
}

git_checkout() {
	local url="$1"
	# Extract the repo name (before the commit hash)
	local repo=$(echo "$url" | sed -e "s/@.*$//")
	# Extract the commit hash
	local commit=$(echo "$url" | sed -e "s/^.*@//" -e "s/#.*$//")
	# Clone the whole repo (this can be a lot -- and you might get throttled)
	# Use the fully qualified encoded URL as the directory name
	# It's pretty darn long, but it should be guaranteed unique, and it's very informative...
	info "Cloning repo [$repo]"
	[ "$DRYRUN" = "1" ] && return
	# If we already have a clean git tree, then we can skip the clone (helps with re-runs)
	if [ -d "$ref" ] && cd "$ref" && git status 2>&1 >/dev/null; then
		info "Already have a clean working repo at [$repo]"
	else
		# Directory is busted, or doesn't exist, so clone fresh from source
		rm -rf "$ref" && git clone "$repo" "$ref"
		cd "$ref"
	fi
	# Rewind back to the exact specified commit in the sbom
	git checkout "$commit"
	cd - 2>&1 >/dev/null
}

checkdeps
platform="amd64"
DRYRUN=0
# Handle command line options
while [ ! -z "$1" ]; do
	case "$1" in
		--dry-run)
			DRYRUN=1
			shift
		;;
		-p|--platform)
			platform="$2"
			shift 2
		;;
		-h|--help)
			usage
			exit 0
		;;
		*)
			image="$1"
			shift
		;;
	esac
done

# Make a directory to work in
mkdir -p sources/"$image-$platform"
cd sources/"$image-$platform"

sbom="$image-$platform.sbom.spdx"
info "Fetching sbom [$platform/$image]"
cosign download attestation \
  --platform linux/$platform \
  --predicate-type=https://spdx.dev/Document \
  cgr.dev/chainguard/$image | \
  jq '.payload | @base64d | fromjson | .predicate' > "$sbom"
info "Fetched sbom [$sbom]"

# TODO: jq would be better here, obviously, but I don't speak jq...
for ref in $(grep "[\"]referenceLocator[\"]: " "$sbom" | sed -e "s/\",$//" -e "s/^.*\"//"); do
	url=$(urldecode "$ref")
	info "Found url [$url]"
	# Handle various strategies for fetching sources
	case "$url" in
		pkg:generic/*vcs_url=git+*)
			# Strip the leading data
			url=$(echo "$url" | sed -e "s/.*git+//")
			git_checkout "$url"
		;;
		pkg:generic/*download_url=*)
			# Strip the leading data
			url=$(echo "$url" | sed -e "s/^.*download_url=//")
			# Get the checksum
			checksum_encoded=$(grep "checksum=.*$ref" "$sbom" | sed -e "s/.*checksum=//" -e "s/&.*$//")
			checksum=$(urldecode "$checksum_encoded")
			checksum_method=$(echo "$checksum" | sed -e "s/:.*$//")
			checksum_hash=$(echo "$checksum" | sed -e "s/^.*://")
			cmd="$checksum_method""sum"
			type "$cmd" 2>&1 >/dev/null || error "Please install [$cmd]"
			info "Downloading archive [$url]"
			[ "$DRYRUN" = "1" ] && continue
			rm -rf "$ref" && mkdir -p "$ref"
			cd "$ref"
			wget -q "$url"
			(echo "$checksum_hash" | $cmd * 2>&1 >/dev/null) || error "Checksum does not match [$(basename $PWD)] != [$checksum_hash]"
			tar xf *
			cd - 2>&1 >/dev/null
		;;
		pkg:github/*)
			# Strip the leading data
			url=$(echo "$url" | sed -e "s|^pkg:github|https://github.com|")
			git_checkout "$url"
		;;
		pkg:apk/wolfi*)
			info "WARNING: Wolfi APK Download not yet handled; skipping [$url]"
		;;
		pkg:oci/image*)
			info "WARNING: OCI Image Download not yet handled; skipping [$url]"
		;;
		*)
			# Strip the leading data
			info "WARNING: Unhandled source download method; skipping [$url]"
		;;
	esac
done
