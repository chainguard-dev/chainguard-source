#!/bin/bash

set -e

error() {
	echo "ERROR: $@" 1>&2
	exit 1
}

info() {
	echo "INFO: $@" 1>&2
}

# Check dependencies
checkdeps() {
	type bunzip2 2>&1 >/dev/null || error "Please install [bunzip2]."
	type cosign 2>&1 >/dev/null || error "Please install [cosign]."
	type jq 2>&1 >/dev/null || error "Please install [jq]."
	type git 2>&1 >/dev/null || error "Please install [git]."
	type gzip 2>&1 >/dev/null || error "Please install [gzip]."
	type sha512sum 2>&1 >/dev/null || error "Please install [sha512sum]."
	type tar 2>&1 >/dev/null || error "Please install [tar]."
	type wget 2>&1 >/dev/null || error "Please install [wget]."
	type xz 2>&1 >/dev/null || error "Please install [xz]."
}

# Decode URLs
urldecode() { : "${*//+/ }"; echo -e "${_//%/\\x}"; }

usage() {
	echo "
$0 [OPTIONS] IMAGE1[:TAG]

Options:
 -p|--platform [amd64|arm64]	Default = amd64
 --dry-run			Dry run (skip actual source downloads)

Image:		Image short name, as in the * in: cgr.dev/chainguard/*
		  - wolfi-base:latest
		  - python:3.11
		  - openjdk
		Default tag = :latest

This tool will create a new directory in your present working directory called sources/
It will then download the SBOM associated with your specified image, and then
use git to clone all upstream source repos, and checkout at the specific
commit used in the image.
"
}

checkdeps
platform="amd64"
dryrun=0
# Handle command line options
while [ ! -z "$1" ]; do
	case "$1" in
		--dry-run)
			dryrun=1
			shift
		;;
		-p|--platform)
			platform="$2"
			shift 2
		;;
		-h|--help)
			usage
			exit 0
		;;
		*)
			image="$1"
			shift
		;;
	esac
done

# Make a directory to work in
mkdir -p sources/"$image-$platform"
cd sources/"$image-$platform"

sbom="$image-$platform.sbom.spdx"
info "Fetching sbom [$platform/$image]"
cosign download attestation \
  --platform linux/$platform \
  --predicate-type=https://spdx.dev/Document \
  cgr.dev/chainguard/$image | \
  jq '.payload | @base64d | fromjson | .predicate' > "$sbom"
info "Fetched sbom [$sbom]"

# TODO: jq would be better here, obviously
# TODO: This only handles git, currently; this needs to handle download_url via curl/wget (verifying checksums, too)
#for ref in $(grep "[\"]referenceLocator[\"]: .*vcs_url" "$sbom" | sed -e "s/.*\?vcs_url=git%2B//" -e "s/\",$//"); do
for ref in $(grep "[\"]referenceLocator[\"]: .*_url=" "$sbom" | sed -e "s/^.*=//" -e "s/\",$//"); do
	url=$(urldecode "$ref")
	info "Found url [$url]"
	case "$url" in
		git+*)
			# Strip the leading git+
			url=$(echo "$url" | sed -e "s/^git+//")
			# Extract the repo name (before the commit hash)
			repo=$(echo "$url" | sed -e "s/@.*$//")
			# Extract the commit hash
			commit=$(echo "$url" | sed -e "s/^.*@//")
			# Clone the whole repo (this can be a lot -- and you might get throttled)
			# Use the fully qualified encoded URL as the directory name
			# It's pretty darn long, but it should be guaranteed unique, and it's very informative...
			info "Cloning repo [$repo]"
			[ "$dryrun" = "1" ] && continue
			rm -rf "$ref" && git clone "$repo" "$ref"
			cd "$ref"
			# Rewind back to the exact specified commit in the sbom
			git checkout "$commit"
			cd - 2>&1 >/dev/null
		;;
		https*)
			# Get the checksum
			checksum_encoded=$(grep "checksum=.*$ref" "$sbom" | sed -e "s/.*checksum=//" -e "s/&.*$//")
			checksum=$(urldecode "$checksum_encoded")
			checksum_method=$(echo "$checksum" | sed -e "s/:.*$//")
			checksum_hash=$(echo "$checksum" | sed -e "s/^.*://")
			cmd="$checksum_method""sum"
			type "$cmd" 2>&1 >/dev/null || error "Please install [$cmd]"
			info "Downloading archive [$url]"
			[ "$dryrun" = "1" ] && continue
			rm -rf "$ref" && mkdir -p "$ref"
			cd "$ref"
			wget -q "$url"
			(echo "$checksum_hash" | $cmd * 2>&1 >/dev/null) || error "Checksum does not match [$(basename $PWD)] != [$checksum_hash]"
			tar xf *
			cd - 2>&1 >/dev/null
		;;
		*)
		;;
	esac
done
